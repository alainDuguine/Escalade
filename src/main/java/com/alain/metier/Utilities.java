package com.alain.metier;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.servlet.http.HttpServletRequest;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.*;

public class Utilities {

    private static final Logger logger = LogManager.getLogger("Utilities");
    public static final String[] paramList = {"nomSpot", "officiel", "departement", "ville", "cotationMin", "cotationMax", "secteurMin", "secteurMax"};

    /**
     * Crée et trie une liste de départements à partir d'une liste d'objets SpotResearchDto
     * @param spotResearchDtoList liste des objets à partir desquels extraire et trier les departements
     * @return le treemap créé
     */
    public static TreeMap<String, String> getDepartementSortedFromList(List<SpotResearchDto> spotResearchDtoList){
        TreeMap<String, String> departementsMap = new TreeMap<>();
        // Injection de la liste dans un treeMap
        for (SpotResearchDto spot : spotResearchDtoList){
            if (!departementsMap.containsKey(spot.getDepartementCode())){
                departementsMap.put(spot.getDepartementCode(), spot.getDepartementNom());
            }
        }
        return  departementsMap;
    }

    /**
     * Vérifie l'email vie une regexp
     * @param email à vérifier
     * @return boolean
     */
    public static boolean checkMail(String email){
        if ( email != null ) {
            if (email.matches("^[\\w._-]+@[\\w._-]+\\.[a-z]{2,4}$")) {
                return true;
            }
        }
        logger.info("Email non conforme " + email);
        return false;
    }

    /**
     * Vérifie si le mot de passe et la confirmation sont équivalentes
     * @param password mot de passe non crypté
     * @param confirmation confirmation non cryptée
     * @return booléen
     */
    public static boolean checkPassword(String password, String confirmation) {
        if (password != null && confirmation != null) {
            return password.equals(confirmation);
        }
        return false;
    }

    /**
     * Vérifie si le string est vide ou null
     * @param string à tester
     * @return true si vide, falsse sinon
     */
    public static boolean isEmpty(String string){
        return (string == null && string.isEmpty());
    }

    /**
     * retourne le champ auquel on a enlevé les espaces superflus
     * @param req httpservlet request
     * @param champ nom du champ à traiter
     * @return champ traité
     */
    public static String getValeurChamp(HttpServletRequest req, String champ) {
        String valeur = req.getParameter(champ);
        if ( valeur == null || valeur.isEmpty()){
            return null;
        }else{
            return valeur.trim();
        }
    }

    /**
     * Encode mot de passe en SHA-2556 avec salt
     * @param password non crypté
     * @return password crypté
     */
    public static String getSecurePassword(String password, byte[] salt){
        String generatedPassword = null;
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(salt);
            byte[] bytes = md.digest(password.getBytes());
            StringBuilder sb = new StringBuilder();
            for (byte aByte : bytes) {
                sb.append(Integer.toString((aByte & 0xff) + 0x100, 16).substring(1));
            }
            generatedPassword = sb.toString();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            logger.error("Problème de Hashage " + e.getMessage());
        }
        return generatedPassword;
    }

    /**
     * Add random data as additional input to hash password.
     * @return the randomly generated bytes
     */
    public static byte[] getSalt() {
        SecureRandom sr = null;
        try {
            sr = SecureRandom.getInstance("SHA1PRNG", "SUN");
        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
            e.printStackTrace();
            logger.error("Problème de génération salt pour hachage mot de passe " + e.getMessage());
        }
        byte[] salt = new byte[16];
        assert sr != null;
        sr.nextBytes(salt);
        return salt;
    }

    /**
     * formate une variable LocalDateTime en français
     * @param date à formater
     * @return date formatée
     */
    public static String dateStringFr(LocalDateTime date){
        String[] moisFr = {"Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"};
        return date.getDayOfMonth() + " " + moisFr[date.getMonthValue()-1] + " " + date.getYear() + " - " + getFullHour(date) + ":" + getFullMinute(date);
    }

    /**
     * Ajoute un "0" si heure < 10
     * @param date date à tester
     * @return heure traitée, sous forme de string
     */
    private static String getFullHour(LocalDateTime date) {
        return (date.getHour()<10?"0":"") + date.getHour();
    }

    /**
     * Ajoute un "0" si minute < 10
     * @param date date à tester
     * @return minute traitée, sous forme de string
     */
    private static String getFullMinute(LocalDateTime date) {
        return (date.getMinute()<10?"0":"") + date.getMinute();
    }

    /**
     * Créé une map contenant les paramètres pour exécuter requête dynamique, à partir de l'objet HttpServletRequest
     * depuis le formulaire de recherche rechercheSpot.jsp
     * @param req servletrequest contenant les paramètres
     * @return une Map contenant le nom du paramètre et sa valeur
     */
    public static Map<String, Object> getParameterMapFromReq(HttpServletRequest req) {
        Map<String, Object> paramMap = new HashMap<>();

        for (String param : paramList) {
            if (param.contains("Min") || param.contains("Max")) {
                if (!req.getParameter(param).equals("")) {
                    if(param.contains("cotation")) {
                        paramMap.put(param, Long.parseLong(req.getParameter(param)));
                    }else{
                        paramMap.put(param, Integer.parseInt(req.getParameter(param)));
                    }
                } else {
                    paramMap.put(param, null);
                }
            }else if (param.equals("officiel")) {
                if (req.getParameter(param) != null) {
                    paramMap.put(param, true);
                } else {
                    paramMap.put(param, false);
                }
            } else {
                paramMap.put(param, req.getParameter(param));
            }
        }
        logger.info("Map de paramètres générée depuis ServletRequest pour requête personnalisée : "+ paramMap.toString());
        return paramMap;
    }

}
